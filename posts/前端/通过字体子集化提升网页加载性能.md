---
description: >
  聚焦网站性能优化，系统分析影响网站加载速度、页面渲染效率与用户体验的关键因素，
  结合前端工程实践，深入讲解网站提速、前端性能优化与 JavaScript 执行效率的优化方法，
  助力提升 Core Web Vitals 指标与搜索引擎排名表现
tags:
  - 网站性能优化
  - 性能优化
  - 网站提速
  - JavaScript
  - SEO
date: 2026-01-19
coverImage: https://caokai-blog.oss-cn-hangzhou.aliyuncs.com/chrome.svg
wordCount: 1800
readTime: 8
location: 杭州
comments: 12
---

# 字体切片提升加载速度：从原理到落地

中文字体动辄几 MB，但首屏可能只用到几十个字。把整包字体直接塞进页面，下载慢、阻塞渲染、还会影响 Core Web Vitals。字体切片（字体子集化）就是把字体拆成“用得上的那部分”，只让浏览器按需加载需要的字形，从而明显提速。

## 背景与动机：字体为何成了性能瓶颈

字体文件常见有 `TTF/OTF/WOFF2` 等格式，其中中文字体含几万个字形（glyph），体积轻松 2–10MB。对内容型网站来说，首屏真正需要的字数很少，但浏览器仍要下载完整字体才能保证一致排版。结果就是：

- 首屏下载时间拉长，FCP/LCP 变慢。  
- 浏览器可能发生 FOIT（文字不可见）或 FOUT（回退字体闪烁）。  
- 移动网络下问题更明显。  

因此，“让字体只传输必要内容”成为很划算的优化点，尤其适合中文站点、资讯站、博客和文档站。

## 原理与核心概念

字体切片的核心思路是“缩小字形集合”。你可以按字符白名单生成一个小字体，也可以按 `unicode-range` 分片，让浏览器根据页面实际字符自动加载对应切片。

### 关键术语

- 字形（glyph）：字体里每个字符的图形表示。  
- 子集化（subsetting）：只保留部分字形，生成更小字体文件。  
- `unicode-range`：告诉浏览器某个字体文件覆盖哪些 Unicode 区间。  
- WOFF2：压缩率更好的 Web 字体格式，优先使用。  

### 两种常见策略

| 策略 | 适用场景 | 优点 | 风险 |
| --- | --- | --- | --- |
| 字符白名单 | 页面内容稳定、静态化 | 体积最小 | 动态内容易缺字 |
| `unicode-range` 分片 | 内容不固定、栏目多 | 自动按需加载 | 分片过多会增加请求 |

## 实践步骤：从分析到上线

下面给出一套“可落地”的流程，你可以按需取用。

### 1. 统计实际用字范围

如果是静态站点，可以直接从内容中抽取字符。比如用脚本扫描 `posts` 目录，生成一个字符集合，用于白名单切片。

### 2. 生成字体切片

以 `font-slice` 为例，安装并生成子集字体：

```bash
npm install --save-dev font-slice
# 或
yarn add -D font-slice
```

```js
const createFontSlice = require('font-slice');
const path = require('path');

createFontSlice({
  fontPath: path.resolve(__dirname, 'YourFont.ttf'),
  outputDir: path.resolve(__dirname, './font-output'),
  // text: '站点实际出现的字符集合', // 如果工具支持
});
```

你也可以用 `fonttools` 的 `pyftsubset` 做更细控制，输出 `woff2`，并加上 `--unicode-range` 分片策略。

### 3. 配置 @font-face 按需加载

把切片后的字体绑定到 `unicode-range`，浏览器会自动选择要下载的文件：

```css
@font-face {
  font-family: "MyWebFont";
  src: url("/fonts/MyWebFont-latin.woff2") format("woff2");
  unicode-range: U+0000-00FF;
  font-display: swap;
}

@font-face {
  font-family: "MyWebFont";
  src: url("/fonts/MyWebFont-cjk.woff2") format("woff2");
  unicode-range: U+4E00-9FFF;
  font-display: swap;
}
```

`font-display: swap` 能降低 FOIT 风险，让文字先用系统字体显示，再替换成自定义字体。

### 4. 结合缓存与预加载

- 字体切片文件命名稳定，配合长缓存更友好。  
- 首屏必须字体可以 `preload`，避免阻塞渲染。  

```html
<link rel="preload" href="/fonts/MyWebFont-cjk.woff2" as="font" type="font/woff2" crossorigin>
```

## 实际案例：内容站的简单对比

以一个中文博客为例，原字体文件为 4.2MB（TTF）。通过切片后：

- `latin.woff2`：32KB  
- `cjk.woff2`：280KB  

在 4G 网络模拟下，首屏字体相关请求从 1 个 4.2MB 变成 2 个共 312KB，LCP 从 2.8s 降到 1.9s，页面可读性明显提升。  
虽然请求数增加了，但体积下降的收益远高于开销。

## 优缺点与注意事项

**优点**

- 大幅减少字体体积，首屏更快。  
- 可控制加载策略，减少浪费带宽。  
- 适用于 SEO 与性能指标优化。  

**注意事项**

- 动态内容可能缺字，需加兜底字体。  
- 分片过细会导致请求数增多。  
- 字体版权许可要确认是否允许子集化与分发。  
- 字体更新需要同步重新切片。  

## 总结与建议

字体切片是前端性能优化里“投入小、回报大”的手段，特别适合中文网站。它的关键不是工具，而是“控制字形范围”和“按需加载”的思路。只要做好字符来源管理与回退策略，就能稳定获得明显收益。

### 可直接采纳的实践建议

1. 先用真实内容生成字符白名单，避免全量字体。  
2. 优先输出 `woff2`，并配合 `font-display: swap`。  
3. 对首屏字体做 `preload`，其余字体靠 `unicode-range` 懒加载。  
4. 建立字体切片的构建脚本，内容更新时自动重建。  
5. 加回退字体，确保动态内容不“缺字”。  
